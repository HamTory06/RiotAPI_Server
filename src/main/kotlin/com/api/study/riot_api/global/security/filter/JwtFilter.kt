package com.api.study.riot_api.global.security.filterimport com.api.study.riot_api.global.security.jwt.JwtParserimport com.api.study.riot_api.global.security.jwt.JwtPropertiesimport com.api.study.riot_api.global.security.jwt.JwtProviderimport org.springframework.http.HttpHeadersimport org.springframework.security.core.context.SecurityContextHolderimport org.springframework.web.filter.OncePerRequestFilterimport javax.servlet.FilterChainimport javax.servlet.http.HttpServletRequestimport javax.servlet.http.HttpServletResponseclass JwtFilter(    private val jwtProperties: JwtProperties,    private val jwtParser: JwtParser) : OncePerRequestFilter() {    companion object {        private const val PREFIX = "Bearer "    }    override fun doFilterInternal(        request: HttpServletRequest,        response: HttpServletResponse,        filterChain: FilterChain    ) {        val token = resolvedToken(request)        if (token.isNotEmpty()) {            SecurityContextHolder.getContext().authentication = jwtParser.getAuthentication(token)        }        filterChain.doFilter(request, response)/*        throw InvalidTokenException        try {            val claims = Jwts.parser()                .setSigningKey(securityProperties.key)                .parseClaimsJws(token)            val jwtHeader = claims.header            val jwtDody = claims.body            val expiration = jwtDody.expiration            if (expiration.before(Date())) {                throw ExpiredTokenException            }            filterChain.doFilter(request, response)        } catch (e: Exception) {            throw InvalidTokenException        }*/    }    private fun resolvedToken(request: HttpServletRequest): String {        val bearerToken: String? = request.getHeader(HttpHeaders.AUTHORIZATION)        bearerToken?.let {            if (bearerToken.startsWith(PREFIX)) {                return bearerToken.substring(PREFIX.length)            }        }        return ""    }}