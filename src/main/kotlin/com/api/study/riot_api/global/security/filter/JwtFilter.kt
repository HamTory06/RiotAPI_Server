package com.api.study.riot_api.global.security.filterimport com.api.study.riot_api.global.security.exception.BusinessExceptionimport com.api.study.riot_api.global.security.exception.InvalidTokenExceptionimport com.api.study.riot_api.global.security.exception.response.JwtExceptionResponseimport com.api.study.riot_api.global.security.jwt.JwtParserimport com.api.study.riot_api.global.security.jwt.JwtPropertiesimport com.api.study.riot_api.global.security.jwt.JwtProviderimport org.springframework.http.HttpHeadersimport org.springframework.http.HttpStatusimport org.springframework.security.core.context.SecurityContextHolderimport org.springframework.web.filter.OncePerRequestFilterimport javax.servlet.FilterChainimport javax.servlet.http.HttpServletRequestimport javax.servlet.http.HttpServletResponseclass JwtFilter(    private val jwtParser: JwtParser) : OncePerRequestFilter() {    companion object {        private const val PREFIX = "Bearer "    }    override fun doFilterInternal(        request: HttpServletRequest, response: HttpServletResponse, filterChain: FilterChain    ) {        val token = resolvedToken(request)        if (token.isNotEmpty())            SecurityContextHolder.getContext().authentication = jwtParser.getAuthentication(token)        else            throw BusinessException(HttpStatus.UNAUTHORIZED.value(), "Invalid Token")        filterChain.doFilter(request, response)    }    private fun resolvedToken(request: HttpServletRequest): String {        val bearerToken: String? = request.getHeader(HttpHeaders.AUTHORIZATION)        bearerToken?.let {            if (bearerToken.startsWith(PREFIX)) {                return bearerToken.substring(PREFIX.length)            }        }        return ""    }}